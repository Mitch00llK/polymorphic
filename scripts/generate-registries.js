/**
 * Component Registry Generator
 *
 * Scans for component manifests and generates registry files.
 * Run with: npm run generate
 *
 * @package Polymorphic
 * @since   1.0.0
 */

const fs = require('fs');
const path = require('path');
const { glob } = require('glob');

// Paths
const ROOT_DIR = path.join(__dirname, '..');
const SRC_DIR = path.join(ROOT_DIR, 'src');
const GENERATED_DIR = path.join(SRC_DIR, 'generated');
const PHP_GENERATED_DIR = path.join(ROOT_DIR, 'includes', 'generated');

/**
 * Parse a manifest.ts file and extract manifest data.
 * Simple regex-based parsing since we can't use TypeScript.
 */
function parseManifestFile(filePath) {
    const content = fs.readFileSync(filePath, 'utf-8');

    // Extract fields using regex
    const typeMatch = content.match(/type:\s*['"]([^'"]+)['"]/);
    const labelMatch = content.match(/label:\s*['"]([^'"]+)['"]/);
    const iconMatch = content.match(/icon:\s*['"]([^'"]+)['"]/);
    const categoryMatch = content.match(/category:\s*['"]([^'"]+)['"]/);
    const phpClassMatch = content.match(/phpClass:\s*['"]([^'"]+)['"]/);
    const supportsChildrenMatch = content.match(/supportsChildren:\s*(true|false)/);

    // Extract CSS (everything between css: ` and `,)
    const cssMatch = content.match(/css:\s*`([\s\S]*?)`/);

    if (!typeMatch || !labelMatch) {
        console.log(`  ‚ö† Skipping ${filePath}: Missing required fields`);
        return null;
    }

    return {
        type: typeMatch[1],
        label: labelMatch[1],
        icon: iconMatch ? iconMatch[1] : 'Box',
        category: categoryMatch ? categoryMatch[1] : 'blocks',
        phpClass: phpClassMatch ? phpClassMatch[1] : '',
        supportsChildren: supportsChildrenMatch ? supportsChildrenMatch[1] === 'true' : false,
        css: cssMatch ? cssMatch[1].trim() : '',
    };
}

/**
 * Scan for all manifest files and load their data.
 */
async function loadManifests() {
    const manifests = [];

    // Find all manifest.ts files in components directory
    const pattern = path.join(SRC_DIR, 'components', '**', 'manifest.ts');
    const files = await glob(pattern, { windowsPathsNoEscape: true });

    console.log(`Found ${files.length} manifest files`);

    for (const file of files) {
        try {
            const manifest = parseManifestFile(file);
            if (manifest) {
                manifests.push(manifest);
                console.log(`  ‚úì Loaded: ${manifest.type}`);
            }
        } catch (err) {
            console.error(`  ‚úó Error loading ${file}:`, err.message);
        }
    }

    return manifests;
}

/**
 * Generate the CSS registry file.
 */
function generateCssRegistry(manifests) {
    const lines = [
        '/**',
        ' * Generated CSS Registry',
        ' * DO NOT EDIT - This file is auto-generated by scripts/generate-registries.js',
        ' */',
        '',
        'const componentCSS = new Map<string, string>();',
        '',
        '// Base styles',
        'componentCSS.set(\'_base\', `',
        '[data-component-id] {',
        '    box-sizing: border-box;',
        '}',
        '`);',
        '',
    ];

    for (const manifest of manifests) {
        lines.push(`// ${manifest.label}`);
        lines.push(`componentCSS.set('${manifest.type}', \`${manifest.css}\`);`);
        lines.push('');
    }

    lines.push('export function getBaseCSS(types: Set<string>): string {');
    lines.push('    const cssBlocks: string[] = [];');
    lines.push('    for (const type of types) {');
    lines.push('        const css = componentCSS.get(type);');
    lines.push('        if (css) cssBlocks.push(css);');
    lines.push('    }');
    lines.push('    return cssBlocks.join("\\n\\n");');
    lines.push('}');
    lines.push('');
    lines.push('export default componentCSS;');

    const outputPath = path.join(GENERATED_DIR, 'cssRegistry.generated.ts');
    fs.writeFileSync(outputPath, lines.join('\n'));
    console.log(`Generated: ${outputPath}`);
}

/**
 * Generate the sidebar components file.
 */
function generateSidebarComponents(manifests) {
    // Collect unique icons
    const icons = new Set();
    for (const m of manifests) {
        icons.add(m.icon);
    }

    const lines = [
        '/**',
        ' * Generated Sidebar Components',
        ' * DO NOT EDIT - This file is auto-generated by scripts/generate-registries.js',
        ' */',
        '',
        'import React from "react";',
        'import {',
        ...Array.from(icons).map(icon => `    ${icon},`),
        '} from "lucide-react";',
        '',
        'export interface ComponentDefinition {',
        '    type: string;',
        '    label: string;',
        '    icon: React.ReactNode;',
        '    category: string;',
        '}',
        '',
        'export const GENERATED_COMPONENTS: ComponentDefinition[] = [',
    ];

    for (const manifest of manifests) {
        lines.push(`    { type: '${manifest.type}', label: '${manifest.label}', icon: <${manifest.icon} size={20} />, category: '${manifest.category}' },`);
    }

    lines.push('];');
    lines.push('');
    lines.push('export default GENERATED_COMPONENTS;');

    const outputPath = path.join(GENERATED_DIR, 'sidebarComponents.generated.tsx');
    fs.writeFileSync(outputPath, lines.join('\n'));
    console.log(`Generated: ${outputPath}`);
}

/**
 * Generate the component renderer registry.
 */
function generateComponentRegistry(manifests) {
    const lines = [
        '/**',
        ' * Generated Component Registry',
        ' * DO NOT EDIT - This file is auto-generated by scripts/generate-registries.js',
        ' */',
        '',
        'import React from "react";',
        'import type { ComponentData } from "../types/components";',
        '',
        '// Import all components',
    ];

    for (const manifest of manifests) {
        // Derive component name from type (e.g., 'testimonialBlock' -> 'TestimonialBlock')
        const componentName = manifest.type.charAt(0).toUpperCase() + manifest.type.slice(1);
        const folderName = componentName;

        lines.push(`import { ${componentName} } from "../components/organisms/${folderName}/${componentName}";`);
    }

    lines.push('');
    lines.push('interface RendererProps {');
    lines.push('    component: ComponentData;');
    lines.push('    context?: "editor" | "preview" | "frontend";');
    lines.push('}');
    lines.push('');
    lines.push('export const GENERATED_RENDERERS: Record<string, React.FC<RendererProps>> = {');

    for (const manifest of manifests) {
        const componentName = manifest.type.charAt(0).toUpperCase() + manifest.type.slice(1);
        lines.push(`    '${manifest.type}': ${componentName} as React.FC<RendererProps>,`);
    }

    lines.push('};');
    lines.push('');
    lines.push('export default GENERATED_RENDERERS;');

    const outputPath = path.join(GENERATED_DIR, 'componentRegistry.generated.ts');
    fs.writeFileSync(outputPath, lines.join('\n'));
    console.log(`Generated: ${outputPath}`);
}

/**
 * Generate PHP component map.
 */
function generatePhpComponentMap(manifests) {
    const lines = [
        '<?php',
        '/**',
        ' * Generated Component Map',
        ' * DO NOT EDIT - This file is auto-generated by scripts/generate-registries.js',
        ' *',
        ' * @package Polymorphic',
        ' * @since   1.0.0',
        ' */',
        '',
        'return [',
    ];

    for (const manifest of manifests) {
        lines.push(`    '${manifest.type}' => \\${manifest.phpClass}::class,`);
    }

    lines.push('];');

    const outputPath = path.join(PHP_GENERATED_DIR, 'component-map.generated.php');
    fs.writeFileSync(outputPath, lines.join('\n'));
    console.log(`Generated: ${outputPath}`);
}

/**
 * Main entry point.
 */
async function main() {
    console.log('üîç Scanning for component manifests...\n');

    // Ensure output directories exist
    if (!fs.existsSync(GENERATED_DIR)) {
        fs.mkdirSync(GENERATED_DIR, { recursive: true });
    }
    if (!fs.existsSync(PHP_GENERATED_DIR)) {
        fs.mkdirSync(PHP_GENERATED_DIR, { recursive: true });
    }

    const manifests = await loadManifests();

    if (manifests.length === 0) {
        console.log('No manifests found. Skipping generation.');
        return;
    }

    console.log('\nüìù Generating registry files...\n');

    generateCssRegistry(manifests);
    generateSidebarComponents(manifests);
    generateComponentRegistry(manifests);
    generatePhpComponentMap(manifests);

    console.log('\n‚úÖ Registry generation complete!');
}

main().catch(console.error);
