/**
 * Component Registry Generator
 *
 * Scans for component manifests and generates registry files.
 * Run with: npm run generate
 *
 * @package Polymorphic
 * @since   1.0.0
 */

import * as fs from 'fs';
import * as path from 'path';
import * as glob from 'glob';

// Paths
const SRC_DIR = path.join(__dirname, '../src');
const GENERATED_DIR = path.join(SRC_DIR, 'generated');
const PHP_GENERATED_DIR = path.join(__dirname, '../includes/generated');

interface ManifestData {
    type: string;
    label: string;
    icon: string;
    category: string;
    css: string;
    phpClass: string;
    supportsChildren?: boolean;
    defaultProps?: Record<string, unknown>;
}

/**
 * Scan for all manifest files and load their data.
 */
function loadManifests(): ManifestData[] {
    const manifests: ManifestData[] = [];

    // Find all manifest.ts files in components directory
    const pattern = path.join(SRC_DIR, 'components', '**', 'manifest.ts');
    const files = glob.sync(pattern);

    console.log(`Found ${files.length} manifest files`);

    for (const file of files) {
        try {
            // We need to require the compiled JS or use ts-node
            // For simplicity, we'll use require with ts-node/register
            delete require.cache[require.resolve(file)];
            const mod = require(file);
            const manifest = mod.manifest || mod.default;

            if (manifest && manifest.type) {
                manifests.push(manifest);
                console.log(`  ‚úì Loaded: ${manifest.type}`);
            }
        } catch (err) {
            console.error(`  ‚úó Error loading ${file}:`, err);
        }
    }

    return manifests;
}

/**
 * Generate the CSS registry file.
 */
function generateCssRegistry(manifests: ManifestData[]): void {
    const lines: string[] = [
        '/**',
        ' * Generated CSS Registry',
        ' * DO NOT EDIT - This file is auto-generated by scripts/generate-registries.ts',
        ' */',
        '',
        'const componentCSS = new Map<string, string>();',
        '',
        '// Base styles',
        `componentCSS.set('_base', \``,
        '[data-component-id] {',
        '    box-sizing: border-box;',
        '}',
        '\`);',
        '',
    ];

    for (const manifest of manifests) {
        lines.push(`// ${manifest.label}`);
        lines.push(`componentCSS.set('${manifest.type}', \`${manifest.css}\`);`);
        lines.push('');
    }

    lines.push('export function getBaseCSS(types: Set<string>): string {');
    lines.push('    const cssBlocks: string[] = [];');
    lines.push('    for (const type of types) {');
    lines.push('        const css = componentCSS.get(type);');
    lines.push('        if (css) cssBlocks.push(css);');
    lines.push('    }');
    lines.push('    return cssBlocks.join("\\n\\n");');
    lines.push('}');
    lines.push('');
    lines.push('export default componentCSS;');

    const outputPath = path.join(GENERATED_DIR, 'cssRegistry.generated.ts');
    fs.writeFileSync(outputPath, lines.join('\n'));
    console.log(`Generated: ${outputPath}`);
}

/**
 * Generate the sidebar components file.
 */
function generateSidebarComponents(manifests: ManifestData[]): void {
    // Collect unique icons
    const icons = new Set<string>();
    for (const m of manifests) {
        icons.add(m.icon);
    }

    const lines: string[] = [
        '/**',
        ' * Generated Sidebar Components',
        ' * DO NOT EDIT - This file is auto-generated by scripts/generate-registries.ts',
        ' */',
        '',
        'import {',
        ...Array.from(icons).map(icon => `    ${icon},`),
        '} from "lucide-react";',
        'import React from "react";',
        '',
        'export interface ComponentDefinition {',
        '    type: string;',
        '    label: string;',
        '    icon: React.ReactNode;',
        '    category: string;',
        '}',
        '',
        'export const GENERATED_COMPONENTS: ComponentDefinition[] = [',
    ];

    for (const manifest of manifests) {
        lines.push(`    { type: '${manifest.type}', label: '${manifest.label}', icon: <${manifest.icon} size={20} />, category: '${manifest.category}' },`);
    }

    lines.push('];');
    lines.push('');
    lines.push('export default GENERATED_COMPONENTS;');

    const outputPath = path.join(GENERATED_DIR, 'sidebarComponents.generated.tsx');
    fs.writeFileSync(outputPath, lines.join('\n'));
    console.log(`Generated: ${outputPath}`);
}

/**
 * Generate the component renderer registry.
 */
function generateComponentRegistry(manifests: ManifestData[]): void {
    const lines: string[] = [
        '/**',
        ' * Generated Component Registry',
        ' * DO NOT EDIT - This file is auto-generated by scripts/generate-registries.ts',
        ' */',
        '',
        'import type { ComponentData } from "../types/components";',
        '',
        '// Import all components',
    ];

    for (const manifest of manifests) {
        // Derive component name from type (e.g., 'testimonialBlock' -> 'TestimonialBlock')
        const componentName = manifest.type.charAt(0).toUpperCase() + manifest.type.slice(1);
        // Derive folder path from type
        const folderName = componentName;

        lines.push(`import { ${componentName} } from "../components/organisms/${folderName}/${componentName}";`);
    }

    lines.push('');
    lines.push('interface RendererProps {');
    lines.push('    component: ComponentData;');
    lines.push('    context?: "editor" | "preview" | "frontend";');
    lines.push('}');
    lines.push('');
    lines.push('export const GENERATED_RENDERERS: Record<string, React.FC<RendererProps>> = {');

    for (const manifest of manifests) {
        const componentName = manifest.type.charAt(0).toUpperCase() + manifest.type.slice(1);
        lines.push(`    '${manifest.type}': ${componentName} as React.FC<RendererProps>,`);
    }

    lines.push('};');
    lines.push('');
    lines.push('export default GENERATED_RENDERERS;');

    const outputPath = path.join(GENERATED_DIR, 'componentRegistry.generated.ts');
    fs.writeFileSync(outputPath, lines.join('\n'));
    console.log(`Generated: ${outputPath}`);
}

/**
 * Generate PHP component map.
 */
function generatePhpComponentMap(manifests: ManifestData[]): void {
    const lines: string[] = [
        '<?php',
        '/**',
        ' * Generated Component Map',
        ' * DO NOT EDIT - This file is auto-generated by scripts/generate-registries.ts',
        ' *',
        ' * @package Polymorphic',
        ' * @since   1.0.0',
        ' */',
        '',
        'return [',
    ];

    for (const manifest of manifests) {
        lines.push(`    '${manifest.type}' => \\${manifest.phpClass}::class,`);
    }

    lines.push('];');

    const outputPath = path.join(PHP_GENERATED_DIR, 'component-map.generated.php');
    fs.writeFileSync(outputPath, lines.join('\n'));
    console.log(`Generated: ${outputPath}`);
}

/**
 * Main entry point.
 */
function main(): void {
    console.log('üîç Scanning for component manifests...\n');

    // Ensure output directories exist
    if (!fs.existsSync(GENERATED_DIR)) {
        fs.mkdirSync(GENERATED_DIR, { recursive: true });
    }
    if (!fs.existsSync(PHP_GENERATED_DIR)) {
        fs.mkdirSync(PHP_GENERATED_DIR, { recursive: true });
    }

    const manifests = loadManifests();

    if (manifests.length === 0) {
        console.log('No manifests found. Skipping generation.');
        return;
    }

    console.log('\nüìù Generating registry files...\n');

    generateCssRegistry(manifests);
    generateSidebarComponents(manifests);
    generateComponentRegistry(manifests);
    generatePhpComponentMap(manifests);

    console.log('\n‚úÖ Registry generation complete!');
}

main();
