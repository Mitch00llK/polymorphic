<?php
/**
 * Frontend Renderer.
 *
 * @package Polymorphic
 * @since   1.0.0
 */

namespace Polymorphic\Frontend;

use Polymorphic\Components\Component_Registry;
use Polymorphic\Cache\Transient_Cache;
use Polymorphic\Settings\Global_Settings;

/**
 * Renders builder content on the frontend.
 *
 * @since 1.0.0
 */
class Renderer {

    /**
     * Component registry.
     *
     * @var Component_Registry
     */
    private Component_Registry $registry;

    /**
     * Cache handler.
     *
     * @var Transient_Cache
     */
    private Transient_Cache $cache;

    /**
     * Constructor.
     *
     * @since 1.0.0
     *
     * @param Component_Registry $registry Component registry.
     */
    public function __construct( Component_Registry $registry ) {
        $this->registry = $registry;
        $this->cache    = new Transient_Cache();
    }

    /**
     * Initialize the renderer.
     *
     * @since 1.0.0
     */
    public function init(): void {
        // Use template_redirect for full page takeover.
        add_action( 'template_redirect', [ $this, 'maybe_take_over_template' ], 1 );

        // Also filter the_content for partial integration (block themes).
        add_filter( 'the_content', [ $this, 'maybe_render_builder_content' ], 5 );

        // Disable wpautop for builder content.
        add_action( 'wp', [ $this, 'maybe_disable_wpautop' ] );

        // Output global CSS variables in head.
        add_action( 'wp_head', [ $this, 'output_global_css_variables' ], 5 );

        // Output generated component CSS in head.
        add_action( 'wp_head', [ $this, 'output_generated_css' ], 6 );
    }

    /**
     * Output global CSS variables in the head.
     *
     * @since 1.0.0
     */
    public function output_global_css_variables(): void {
        $global_settings = Global_Settings::get_instance();
        $css = $global_settings->generate_css_variables();

        if ( ! empty( $css ) ) {
            echo '<style id="polymorphic-global-css">' . "\n";
            // phpcs:ignore WordPress.Security.EscapeOutput.OutputNotEscaped
            echo $css;
            echo '</style>' . "\n";
        }
    }

    /**
     * Output generated component CSS in the head.
     *
     * This CSS is generated by the builder when saving and contains
     * component-specific styles using generated class names.
     *
     * @since 1.0.0
     */
    public function output_generated_css(): void {
        if ( ! is_singular() ) {
            return;
        }

        $post_id = get_the_ID();

        if ( ! $this->is_builder_enabled( $post_id ) ) {
            return;
        }

        $data = get_post_meta( $post_id, '_polymorphic_data', true );

        if ( empty( $data ) ) {
            return;
        }

        $data = json_decode( $data, true );

        if ( json_last_error() !== JSON_ERROR_NONE ) {
            return;
        }

        // Output generated CSS.
        if ( ! empty( $data['generatedCss'] ) ) {
            echo '<style id="polymorphic-generated-css">' . "\n";
            // phpcs:ignore WordPress.Security.EscapeOutput.OutputNotEscaped -- CSS is sanitized on save.
            echo $data['generatedCss'];
            echo "\n" . '</style>' . "\n";
        }

        // Output custom CSS.
        if ( ! empty( $data['customCss'] ) ) {
            echo '<style id="polymorphic-custom-css">' . "\n";
            // phpcs:ignore WordPress.Security.EscapeOutput.OutputNotEscaped -- CSS is sanitized on save.
            echo $data['customCss'];
            echo "\n" . '</style>' . "\n";
        }
    }

    /**
     * Disable wpautop for posts with builder enabled.
     *
     * @since 1.0.0
     */
    public function maybe_disable_wpautop(): void {
        if ( ! is_singular() ) {
            return;
        }

        $post_id = get_the_ID();

        if ( $this->is_builder_enabled( $post_id ) ) {
            // Remove WordPress auto-paragraph formatting.
            remove_filter( 'the_content', 'wpautop' );
            remove_filter( 'the_content', 'wptexturize' );

            // Disable block styling that wraps content.
            add_filter( 'render_block', [ $this, 'unwrap_post_content_block' ], 10, 2 );
        }
    }

    /**
     * Remove wrapper from post-content block.
     *
     * @since 1.0.0
     *
     * @param string $block_content Block HTML.
     * @param array  $block         Block data.
     * @return string Modified HTML.
     */
    public function unwrap_post_content_block( string $block_content, array $block ): string {
        if ( 'core/post-content' === $block['blockName'] ) {
            // Return just the inner content without the wrapper divs.
            return $this->render( get_the_ID() );
        }

        return $block_content;
    }

    /**
     * Take over the entire template for builder pages.
     *
     * @since 1.0.0
     */
    public function maybe_take_over_template(): void {
        if ( ! is_singular() ) {
            return;
        }

        $post_id = get_the_ID();

        if ( ! $this->is_builder_enabled( $post_id ) ) {
            return;
        }

        // Check if full takeover is enabled (can be filtered).
        $full_takeover = apply_filters( 'polymorphic/render/full_takeover', true, $post_id );

        if ( ! $full_takeover ) {
            return;
        }

        // Load custom template.
        $this->render_full_page( $post_id );
        exit;
    }

    /**
     * Render full page with custom template.
     *
     * @since 1.0.0
     *
     * @param int $post_id Post ID.
     */
    private function render_full_page( int $post_id ): void {
        $post = get_post( $post_id );

        if ( ! $post ) {
            return;
        }

        // Get rendered content.
        $content = $this->render( $post_id );

        // Check for custom template.
        $template = POLYMORPHIC_PATH . 'templates/frontend-page.php';

        if ( file_exists( $template ) ) {
            // Pass variables to template.
            set_query_var( 'polymorphic_content', $content );
            set_query_var( 'polymorphic_post', $post );

            include $template;
        } else {
            // Fallback: output basic HTML structure.
            $this->render_default_template( $post, $content );
        }
    }

    /**
     * Render default full-page template.
     *
     * @since 1.0.0
     *
     * @param \WP_Post $post    Post object.
     * @param string   $content Rendered content.
     */
    private function render_default_template( \WP_Post $post, string $content ): void {
        ?>
<!DOCTYPE html>
<html <?php language_attributes(); ?>>
<head>
    <meta charset="<?php bloginfo( 'charset' ); ?>">
    <meta name="viewport" content="width=device-width, initial-scale=1">
    <?php wp_head(); ?>
</head>
<body <?php body_class( 'polymorphic-page' ); ?>>
<?php wp_body_open(); ?>

<main class="polymorphic-main" role="main">
    <?php echo $content; // phpcs:ignore WordPress.Security.EscapeOutput ?>
</main>

<?php wp_footer(); ?>
</body>
</html>
        <?php
    }

    /**
     * Render builder content if enabled for this post.
     *
     * @since 1.0.0
     *
     * @param string $content Original post content.
     * @return string Modified content.
     */
    public function maybe_render_builder_content( string $content ): string {
        // Only on singular pages.
        if ( ! is_singular() ) {
            return $content;
        }

        $post_id = get_the_ID();

        // Check if builder is enabled.
        if ( ! $this->is_builder_enabled( $post_id ) ) {
            return $content;
        }

        // If full takeover is enabled, this won't be reached.
        // This is fallback for non-takeover mode.
        return $this->render( $post_id );
    }

    /**
     * Check if builder is enabled for a post.
     *
     * @since 1.0.0
     *
     * @param int $post_id Post ID.
     * @return bool
     */
    private function is_builder_enabled( int $post_id ): bool {
        return (bool) get_post_meta( $post_id, '_polymorphic_enabled', true );
    }

    /**
     * Render builder content for a post.
     *
     * @since 1.0.0
     *
     * @param int $post_id Post ID.
     * @return string Rendered HTML.
     */
    public function render( int $post_id ): string {
        // Try to get from cache.
        $cached = $this->cache->get_rendered( $post_id );
        if ( false !== $cached ) {
            return $cached;
        }

        $data = get_post_meta( $post_id, '_polymorphic_data', true );

        if ( empty( $data ) ) {
            return '';
        }

        $data = json_decode( $data, true );

        if ( json_last_error() !== JSON_ERROR_NONE || empty( $data['components'] ) ) {
            return '';
        }

        /**
         * Fires before rendering begins.
         *
         * @since 1.0.0
         *
         * @param int   $post_id Post ID.
         * @param array $data    Builder data.
         */
        do_action( 'polymorphic/render/before', $post_id, $data );

        $html = '';

        foreach ( $data['components'] as $component ) {
            $html .= $this->registry->render( $component, 'frontend' );
        }

        /**
         * Fires after rendering completes.
         *
         * @since 1.0.0
         *
         * @param int    $post_id Post ID.
         * @param string $html    Rendered HTML.
         */
        do_action( 'polymorphic/render/after', $post_id, $html );

        /**
         * Filter the final rendered HTML.
         *
         * @since 1.0.0
         *
         * @param string $html    Rendered HTML.
         * @param int    $post_id Post ID.
         */
        $html = apply_filters( 'polymorphic/render/page', $html, $post_id );

        // Cache the result.
        $this->cache->set_rendered( $post_id, $html );

        return $html;
    }
}

